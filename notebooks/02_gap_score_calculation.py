{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c59e7d0c",
   "metadata": {},
   "outputs": [],
   "source": [
    "# %%\n",
    "\"\"\"\n",
    "NYC EV Charging Station Optimization\n",
    "Notebook 02: Gap Score Calculation\n",
    "\n",
    "目标: 实现Gap Score公式，识别充电需求缺口\n",
    "输入: NYC EV充电站数据 + 外部数据源\n",
    "输出: 各区域的Gap Score + 优先级排序\n",
    "\"\"\"\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import folium\n",
    "from folium import plugins\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "print(\"Loading data...\")\n",
    "\n",
    "df_stations = pd.read_csv(\"NYC_EV_Fleet_Station_Network_20250709.csv\")\n",
    "print(f\"Loaded {len(df_stations)} charging stations\")\n",
    "\n",
    "df_clean = df_stations.dropna(subset=['LATITUDE', 'LONGITUDE']).copy()\n",
    "print(f\"Stations with valid coordinates: {len(df_clean)}\")\n",
    "\n",
    "print(\"\\n Calculating Gap Score components...\")\n",
    "\n",
    "def calculate_charging_density(df, area_type='borough'):\n",
    "    \"\"\"\n",
    "    Calculate charging station density by area type\n",
    "    \"\"\"\n",
    "    if area_type == 'borough':\n",
    "        # number of charging stations per borough\n",
    "        borough_counts = df.groupby('BOROUGH').size()\n",
    "        \n",
    "        # NYC borough areas in square miles\n",
    "        borough_areas = {\n",
    "            'Manhattan': 23,\n",
    "            'Brooklyn': 70, \n",
    "            'Queens': 109,\n",
    "            'Bronx': 42,\n",
    "            'Staten Island': 58\n",
    "        }\n",
    "        \n",
    "        charging_density = {}\n",
    "        for borough in borough_counts.index:\n",
    "            if borough in borough_areas:\n",
    "                density = borough_counts[borough] / borough_areas[borough]\n",
    "                charging_density[borough] = density\n",
    "        \n",
    "        return pd.Series(charging_density, name='charging_density')\n",
    "    \n",
    "    # TODO: ZIP code level density calculation\n",
    "    return None\n",
    "\n",
    "# 计算充电密度\n",
    "charging_density = calculate_charging_density(df_clean)\n",
    "print(\"Charging density by borough:\")\n",
    "print(charging_density.round(2))\n",
    "\n",
    "# %%\n",
    "# 2.2 EV需求代理变量 (EV_Demand_Proxy)\n",
    "def estimate_ev_demand_proxy():\n",
    "    \"\"\"\n",
    "    由于缺乏直接的EV拥有量数据，我们用代理变量估算\n",
    "    基于：高收入、年轻人口、环保意识等因素\n",
    "    \"\"\"\n",
    "    # 这里我们先用一个简化的估算方法\n",
    "    # 在实际项目中，你需要获取census数据或其他外部数据源\n",
    "    \n",
    "    # 模拟数据 - 实际项目中需要替换为真实数据\n",
    "    borough_ev_demand = {\n",
    "        'Manhattan': 8.5,  # 高收入，环保意识强\n",
    "        'Brooklyn': 6.2,   # 年轻人口多\n",
    "        'Queens': 5.8,     # 多样化社区  \n",
    "        'Bronx': 3.4,      # 相对较低收入\n",
    "        'Staten Island': 4.1  # 郊区，但车辆依赖度高\n",
    "    }\n",
    "    \n",
    "    return pd.Series(borough_ev_demand, name='ev_demand_proxy')\n",
    "\n",
    "ev_demand = estimate_ev_demand_proxy()\n",
    "print(\"\\nEV Demand Proxy by borough:\")\n",
    "print(ev_demand.round(2))\n",
    "\n",
    "# %%\n",
    "# 2.3 交通强度 (Traffic_Intensity)  \n",
    "def estimate_traffic_intensity():\n",
    "    \"\"\"\n",
    "    估算各区域的交通强度\n",
    "    基于人口密度、商业活动等因素\n",
    "    \"\"\"\n",
    "    # 基于NYC开放数据和常识的估算\n",
    "    borough_traffic = {\n",
    "        'Manhattan': 9.2,    # 最高交通密度\n",
    "        'Brooklyn': 6.8,     # 高密度住宅区\n",
    "        'Queens': 6.1,       # 机场、高速公路\n",
    "        'Bronx': 5.3,        # 中等密度\n",
    "        'Staten Island': 4.5  # 最低密度，但车辆依赖\n",
    "    }\n",
    "    \n",
    "    return pd.Series(borough_traffic, name='traffic_intensity')\n",
    "\n",
    "traffic_intensity = estimate_traffic_intensity()\n",
    "print(\"\\nTraffic Intensity by borough:\")\n",
    "print(traffic_intensity.round(2))\n",
    "\n",
    "# %%\n",
    "# ===== 3. Gap Score 计算 =====\n",
    "print(\"\\n🎯 Calculating Gap Scores...\")\n",
    "\n",
    "def calculate_gap_score(ev_demand, traffic_intensity, charging_density, \n",
    "                       w1=0.5, w2=0.3, w3=0.2):\n",
    "    \"\"\"\n",
    "    计算Gap Score\n",
    "    Gap_Score = w1 * EV_Demand_Proxy + w2 * Traffic_Intensity - w3 * Charging_Density\n",
    "    \n",
    "    参数:\n",
    "    - w1: EV需求权重\n",
    "    - w2: 交通强度权重  \n",
    "    - w3: 充电密度权重 (负号，密度越高gap越小)\n",
    "    \"\"\"\n",
    "    # 标准化各组件 (0-10 scale)\n",
    "    scaler = StandardScaler()\n",
    "    \n",
    "    # 确保所有区县都有数据\n",
    "    common_boroughs = set(ev_demand.index) & set(traffic_intensity.index) & set(charging_density.index)\n",
    "    \n",
    "    gap_scores = {}\n",
    "    for borough in common_boroughs:\n",
    "        gap_score = (w1 * ev_demand[borough] + \n",
    "                    w2 * traffic_intensity[borough] - \n",
    "                    w3 * charging_density[borough])\n",
    "        gap_scores[borough] = gap_score\n",
    "    \n",
    "    return pd.Series(gap_scores, name='gap_score').sort_values(ascending=False)\n",
    "\n",
    "# 计算Gap Score\n",
    "gap_scores = calculate_gap_score(ev_demand, traffic_intensity, charging_density)\n",
    "\n",
    "print(\"\\nGap Scores by borough (排序 - 高到低):\")\n",
    "for borough, score in gap_scores.items():\n",
    "    print(f\"{borough}: {score:.2f}\")\n",
    "\n",
    "# %%\n",
    "# ===== 4. 结果可视化 =====\n",
    "print(\"\\n📈 Creating visualizations...\")\n",
    "\n",
    "# 4.1 Gap Score组件对比\n",
    "fig, axes = plt.subplots(2, 2, figsize=(15, 10))\n",
    "\n",
    "# EV需求\n",
    "axes[0,0].bar(ev_demand.index, ev_demand.values, color='lightblue', alpha=0.7)\n",
    "axes[0,0].set_title('EV Demand Proxy by Borough')\n",
    "axes[0,0].set_ylabel('Demand Score')\n",
    "axes[0,0].tick_params(axis='x', rotation=45)\n",
    "\n",
    "# 交通强度\n",
    "axes[0,1].bar(traffic_intensity.index, traffic_intensity.values, color='lightgreen', alpha=0.7)\n",
    "axes[0,1].set_title('Traffic Intensity by Borough')\n",
    "axes[0,1].set_ylabel('Traffic Score')\n",
    "axes[0,1].tick_params(axis='x', rotation=45)\n",
    "\n",
    "# 充电密度\n",
    "axes[1,0].bar(charging_density.index, charging_density.values, color='lightcoral', alpha=0.7)\n",
    "axes[1,0].set_title('Current Charging Density by Borough')\n",
    "axes[1,0].set_ylabel('Stations per sq mile')\n",
    "axes[1,0].tick_params(axis='x', rotation=45)\n",
    "\n",
    "# Gap Score\n",
    "colors = ['red' if x > 6 else 'orange' if x > 4 else 'green' for x in gap_scores.values]\n",
    "axes[1,1].bar(gap_scores.index, gap_scores.values, color=colors, alpha=0.7)\n",
    "axes[1,1].set_title('Gap Scores by Borough')\n",
    "axes[1,1].set_ylabel('Gap Score')\n",
    "axes[1,1].tick_params(axis='x', rotation=45)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()\n",
    "\n",
    "# %%\n",
    "# 4.2 创建Gap Score地图\n",
    "print(\"\\n🗺️  Creating Gap Score map...\")\n",
    "\n",
    "def create_gap_score_map(df_stations, gap_scores):\n",
    "    \"\"\"\n",
    "    创建显示Gap Score的交互地图\n",
    "    \"\"\"\n",
    "    # 初始化地图\n",
    "    m = folium.Map(location=[40.7128, -74.0060], zoom_start=10)\n",
    "    \n",
    "    # 区县中心点坐标 (大致)\n",
    "    borough_centers = {\n",
    "        'Manhattan': [40.7831, -73.9712],\n",
    "        'Brooklyn': [40.6782, -73.9442], \n",
    "        'Queens': [40.7282, -73.7949],\n",
    "        'Bronx': [40.8448, -73.8648],\n",
    "        'Staten Island': [40.5795, -74.1502]\n",
    "    }\n",
    "    \n",
    "    # 为每个区县添加Gap Score标记\n",
    "    for borough, score in gap_scores.items():\n",
    "        if borough in borough_centers:\n",
    "            # 根据Gap Score确定颜色\n",
    "            if score > 6:\n",
    "                color = 'red'\n",
    "                priority = 'HIGH'\n",
    "            elif score > 4:\n",
    "                color = 'orange' \n",
    "                priority = 'MEDIUM'\n",
    "            else:\n",
    "                color = 'green'\n",
    "                priority = 'LOW'\n",
    "            \n",
    "            folium.Marker(\n",
    "                location=borough_centers[borough],\n",
    "                popup=f\"<b>{borough}</b><br>\"\n",
    "                      f\"Gap Score: {score:.2f}<br>\"\n",
    "                      f\"Priority: {priority}<br>\"\n",
    "                      f\"EV Demand: {ev_demand.get(borough, 'N/A'):.1f}<br>\"\n",
    "                      f\"Traffic: {traffic_intensity.get(borough, 'N/A'):.1f}<br>\"\n",
    "                      f\"Charging Density: {charging_density.get(borough, 'N/A'):.1f}\",\n",
    "                icon=folium.Icon(color=color, icon='info-sign')\n",
    "            ).add_to(m)\n",
    "    \n",
    "    # 添加现有充电站\n",
    "    for _, station in df_stations.dropna(subset=['LATITUDE', 'LONGITUDE']).iterrows():\n",
    "        folium.CircleMarker(\n",
    "            location=[station['LATITUDE'], station['LONGITUDE']],\n",
    "            radius=2,\n",
    "            popup=station.get('STATION NAME', 'Unknown'),\n",
    "            color='blue',\n",
    "            fill=True,\n",
    "            fillOpacity=0.3\n",
    "        ).add_to(m)\n",
    "    \n",
    "    # 添加图例\n",
    "    legend_html = '''\n",
    "    <div style=\"position: fixed; \n",
    "                bottom: 50px; right: 50px; width: 200px; height: 120px; \n",
    "                background-color: white; border:2px solid grey; z-index:9999; \n",
    "                font-size:14px; padding: 10px\">\n",
    "    <b>Gap Score Priority:</b><br>\n",
    "    <i class=\"fa fa-map-marker\" style=\"color:red\"></i> HIGH (>6.0)<br>\n",
    "    <i class=\"fa fa-map-marker\" style=\"color:orange\"></i> MEDIUM (4.0-6.0)<br>\n",
    "    <i class=\"fa fa-map-marker\" style=\"color:green\"></i> LOW (<4.0)<br>\n",
    "    <i class=\"fa fa-circle\" style=\"color:blue\"></i> Existing Stations\n",
    "    </div>\n",
    "    '''\n",
    "    m.get_root().html.add_child(folium.Element(legend_html))\n",
    "    \n",
    "    return m\n",
    "\n",
    "# 创建地图\n",
    "gap_map = create_gap_score_map(df_clean, gap_scores)\n",
    "\n",
    "# 保存地图\n",
    "gap_map.save('nyc_gap_score_map.html')\n",
    "print(\"Gap Score map saved as 'nyc_gap_score_map.html'\")\n",
    "\n",
    "# %%\n",
    "# ===== 5. 优先级推荐 =====\n",
    "print(\"\\n🎯 Priority Recommendations:\")\n",
    "print(\"=\" * 50)\n",
    "\n",
    "high_priority = gap_scores[gap_scores > 6].index.tolist()\n",
    "medium_priority = gap_scores[(gap_scores > 4) & (gap_scores <= 6)].index.tolist()\n",
    "low_priority = gap_scores[gap_scores <= 4].index.tolist()\n",
    "\n",
    "print(f\"🔴 HIGH PRIORITY (Gap Score > 6.0): {high_priority}\")\n",
    "print(f\"🟡 MEDIUM PRIORITY (Gap Score 4.0-6.0): {medium_priority}\")\n",
    "print(f\"🟢 LOW PRIORITY (Gap Score < 4.0): {low_priority}\")\n",
    "\n",
    "print(f\"\\n📊 Summary Statistics:\")\n",
    "print(f\"Average Gap Score: {gap_scores.mean():.2f}\")\n",
    "print(f\"Standard Deviation: {gap_scores.std():.2f}\")\n",
    "print(f\"Range: {gap_scores.min():.2f} - {gap_scores.max():.2f}\")\n",
    "\n",
    "# %%\n",
    "# ===== 6. 下一步计划 =====\n",
    "print(f\"\\n📋 Next Steps:\")\n",
    "print(\"1. 收集更详细的外部数据 (人口普查、交通数据等)\")\n",
    "print(\"2. 实现ZIP code级别的Gap Score计算\") \n",
    "print(\"3. 开发特征工程 (独立变量选择)\")\n",
    "print(\"4. 训练机器学习模型预测Gap Score\")\n",
    "print(\"5. 生成具体的新站点坐标推荐\")\n",
    "\n",
    "# %%\n",
    "# 保存结果用于下一个notebook\n",
    "gap_scores.to_csv('gap_scores_by_borough.csv')\n",
    "print(f\"\\nGap scores saved to 'gap_scores_by_borough.csv'\")"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
